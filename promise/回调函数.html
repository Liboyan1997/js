<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
	</body>
</html>
<script type="text/javascript">
	// 一个函数被作为参数传递给另一个函数（在这里我们把另一个函数叫做“otherFunction”）
	// ，回调函数在otherFunction中被调用。
	
	//第一种方法：匿名函数作为回调函数
	// var generalLastName = "Cliton";
	// function getInput(options, callback){
	//     var arr = [];
	//     arr.push(options);
	//     //将全局变量generalLastName传递给回调函数
	//     callback(generalLastName,arr);
	// }
	// getInput({name:"Rich",speciality:"Javascript"}, function(generalLastName,arr){
	//     console.log(generalLastName + ":" + arr[0].speciality) // Cliton:Javascript
	// });
	//第二种方法：命名函数作为回调函数
	// var generalLastName = "Cliton";
	// function getInput(options, callback){
	//     var arr = [];
	//     arr.push(options);
	//     //将全局变量generalLastName传递给回调函数
	//     callback(generalLastName,arr);
	// }
	// function call(generalLastName,arr){
	//     console.log(generalLastName + ":" + arr[0].speciality) // Cliton:Javascript
	// }
	// getInput({name:"Rich",speciality:"Javascript"}, call);
	
	//回调链:多到一定程度,叫回调地狱
		function fun1(f){ 
			console.log("fun1_同步");
			setTimeout(function(){
	            console.log("fun1_异步");
				f(); 
	        },1000);
		}
		
		function fun2(f){
			console.log("fun2_同步");
			setTimeout(function(){
	            console.log("fun2_异步");
				f();
	        },1000);
		}
		
		function fun3(f){
			console.log("fun3_同步");
			setTimeout(function(){
	            console.log("fun3_异步");
				f();
	        },1000);
		}
		
		function fun4(){
			console.log("fun4_同步");
			setTimeout(function(){
	            console.log("fun4_异步");
	        },1000);
		}
		
	// fun1(function(){
	// 	console.log("a");
	// });
	// fun1(fun4)
	fun1(function(){
		fun2(function(){
			fun3(fun4)
		})
	})
</script>